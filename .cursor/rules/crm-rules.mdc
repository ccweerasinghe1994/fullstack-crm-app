---
alwaysApply: true
---

# CRM Application - Project Rules

You are an expert AI programming assistant specializing in a PNPM monorepo for a full-stack CRM application.

## Project Structure

```
frenchCompanyInterview/
├── apps/
│   ├── api/          # Backend API (Express + TypeScript)
│   └── web/          # Frontend (React + Vite + shadcn/ui)
├── packages/
│   └── shared/       # Shared types, utilities, constants
└── pnpm-workspace.yaml
```

## Backend (apps/api)

**Tech Stack:**
- Node.js + Express + TypeScript
- Prisma ORM + PostgreSQL
- Vitest (unit tests)
- Port: 3000

**Architecture Patterns:**
- Repository Pattern for data access (REQUIRED)
- Service layer for business logic
- Controller layer for API endpoints
- Dependency injection for modularity

**Rules:**
- ALL database logic MUST be in repositories (never call Prisma directly in services/controllers)
- Use Zod for validation schemas
- Export explicit types for Express app and server
- Prefix unused parameters with underscore (e.g., `_req`, `_next`)
- Use proper error handling middleware
- Environment variables via dotenv
- **ALWAYS run `pnpm test:run` after making changes** (see Testing Requirements)

**File Organization:**
```
src/
├── controllers/    # API endpoint handlers
├── services/       # Business logic
├── repositories/   # Data access layer (Prisma)
├── middleware/     # Express middleware
├── validators/     # Zod schemas
├── types/          # TypeScript types
└── index.ts        # Server entry point
```

## Frontend (apps/web)

**Tech Stack:**
- React 19 + TypeScript
- Vite (bundler)
- TanStack Router (routing)
- TanStack Query (data fetching)
- Tailwind CSS 4 (styling)
- shadcn/ui (component library)
- Biome (linting/formatting)
- Vitest (unit tests)
- Port: 5173

**Rules:**
- ALL UI components MUST use shadcn/ui components
- Use TanStack Query for all API calls (never fetch directly)
- Use TanStack Router for routing
- Use Zod for form validation (shared schemas from packages/shared)
- Use Tailwind CSS for styling (no inline styles)
- Component naming: PascalCase
- File naming: kebab-case for utilities, PascalCase for components

**File Organization:**
```
src/
├── components/     # React components
│   └── ui/        # shadcn/ui components
├── routes/         # TanStack Router routes
├── lib/            # Utilities and helpers
├── integrations/   # Third-party integrations
└── styles.css      # Global styles
```

**shadcn/ui Components:**

shadcn components are located in `apps/web/src/components/ui/`:

```bash
# Navigate to the web app
cd apps/web

# Add shadcn components
pnpx shadcn@latest add button
pnpx shadcn@latest add card
pnpx shadcn@latest add input
pnpx shadcn@latest add form
pnpx shadcn@latest add dialog
pnpx shadcn@latest add table
pnpx shadcn@latest add sheet
pnpx shadcn@latest add select
# ... etc
```

OR run from root with working directory flag:

```bash
# From project root
pnpx shadcn@latest add button --cwd apps/web
```

Components will be added to `apps/web/src/components/ui/`

**Usage in Apps:**

```tsx
// Import from local UI components
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { cn } from "@/lib/utils";
```

**shadcn Configuration:**
- Style: `new-york`
- Base color: `zinc`
- CSS variables: `enabled`
- Icon library: `lucide-react`
- Config location: `apps/web/components.json`

## Shared Packages

**packages/shared (`@crm/shared`):**
- Shared TypeScript types and interfaces
- Zod validation schemas (e.g., customer validation)
- Constants and enums (e.g., API endpoints)
- Utility functions

**Usage:**
```typescript
import { customerSchema } from "@crm/shared/validators";
import { API_ENDPOINTS } from "@crm/shared/constants";
import type { Customer } from "@crm/shared/types";
```


## Documentation Structure

**Organization Pattern:**
Documentation is organized into two main locations based on scope:

### 1. Project-Wide Documentation (`docs/`)

Located at the root level for project-wide documentation:

```
docs/
├── README.md              # Index for project-wide docs
├── DOCKER.md             # Docker setup and infrastructure
├── PROJECT_STRUCTURE.md  # Complete monorepo structure
└── prd-prep.md          # Tech stack decisions & PRD
```

**When to use:**
- Infrastructure setup (Docker, CI/CD)
- Project architecture and structure
- Cross-cutting concerns (authentication, deployment)
- Product requirements and tech stack decisions

### 2. Application-Specific Documentation (`apps/{app}/docs/`)

Each application has its own `docs/` folder organized by category:

```
apps/api/docs/
├── README.md             # Index for API documentation
├── setup/                # Setup & Configuration
│   ├── PRISMA_SETUP.md
│   ├── TSOA_SETUP.md
│   ├── VITEST_SETUP_SUMMARY.md
│   ├── MIGRATION_*.md
│   └── DATABASE_STATUS.md
├── api/                  # API Reference & Implementation
│   ├── API_DOCUMENTATION.md
│   └── IMPLEMENTATION_SUMMARY.md
└── guides/               # Development Guides & Best Practices
    ├── DEVELOPMENT_WORKFLOW.md
    ├── TESTING.md
    └── *_QUICKSTART.md
```

**Category Guidelines:**

**`setup/`** - Initial configuration and setup guides:
- Tool/framework setup (Prisma, TSOA, Vitest, etc.)
- Migration guides
- Database configuration
- Environment setup
- Dependency installation

**`api/`** (or equivalent for other apps) - Core functionality documentation:
- API endpoint reference
- Implementation details
- Architecture patterns
- Data models and schemas
- Integration guides

**`guides/`** - Developer workflow and best practices:
- Development workflows
- Testing strategies
- Debugging guides
- Best practices
- Quick reference guides

**Documentation Rules:**

1. **File Naming:**
   - Use UPPERCASE with underscores: `SETUP_GUIDE.md`
   - Descriptive names: `PRISMA_SETUP.md` not `SETUP.md`
   - Suffix guides with `_GUIDE.md`, quickstarts with `_QUICKSTART.md`
   - Migration docs: `MIGRATION_TOOL_VERSION.md`

2. **Always Include README:**
   - Each `docs/` folder MUST have a `README.md` index
   - Index should explain structure and link to all documents
   - Include quick links to most important docs

3. **Content Organization:**
   - Start with a clear title and description
   - Use consistent heading hierarchy (H1 for title, H2 for sections)
   - Include table of contents for long documents
   - Add "Quick Start" or "TL;DR" section at the top
   - Link to related documentation

4. **Keep READMEs at Package Level:**
   - `apps/api/README.md` - API package overview (NOT in docs/)
   - `apps/web/README.md` - Frontend package overview (NOT in docs/)
   - `packages/*/README.md` - Package overview (NOT in docs/)
   - Use READMEs for quick reference; detailed docs go in `docs/`

5. **Update References:**
   - When moving docs, update all links in README files
   - Update links in other documentation
   - Check for references in code comments

6. **Examples:**

```markdown
# Good Documentation Structure
apps/api/docs/setup/PRISMA_SETUP.md          ✅
apps/api/docs/guides/TESTING_GUIDE.md        ✅
apps/api/docs/api/ENDPOINTS.md               ✅
docs/DOCKER_GUIDE.md                         ✅

# Bad Documentation Structure
apps/api/SETUP.md                            ❌ (should be in docs/setup/)
apps/api/docs/prisma.md                      ❌ (unclear category)
docs/api-endpoints.md                        ❌ (app-specific, should be in apps/api/docs/)
apps/api/docs/docker.md                      ❌ (project-wide, should be in root docs/)
```

## Development Workflow

**Commands:**
- `pnpm dev` - Start all apps
- `pnpm dev:api` - Start backend only
- `pnpm dev:web` - Start frontend only
- `pnpm build` - Build all apps
- `pnpm test` - Run all tests
- `pnpm test:run` - Run tests once (use after API changes)
- `pnpm test:watch` - Run tests in watch mode
- `pnpm test:coverage` - Run tests with coverage report
- `pnpm type-check` - TypeScript type checking

**Package Naming:**
- Backend: `@crm/api`
- Frontend: `@crm/web`
- Shared: `@crm/shared`

## Testing Requirements (TDD)

**Vitest for unit tests:**
- Test files: `*.test.ts` or `*.spec.ts`
- Repository layer tests
- Service layer tests
- API endpoint tests
- Component tests

**Playwright for E2E tests:**
- Test files: `*.e2e.ts`
- Full CRUD workflows
- Form validation
- Error handling

**Rules:**
- Write tests FIRST (Test-Driven Development)
- Each feature must have corresponding tests
- Mock external dependencies
- Test edge cases and error scenarios

**Critical Testing Workflow for API Changes:**

⚠️ **MANDATORY: After ANY change to `apps/api`, you MUST run tests before considering the task complete:**

```bash
cd apps/api
pnpm test:run
```

If tests fail:
1. Fix the failing tests or code
2. Run tests again until all pass
3. Only then consider the task complete

This applies to:
- Adding new API endpoints
- Modifying existing endpoints
- Changing business logic in services
- Updating data access in repositories
- Modifying middleware or error handlers
- Changing types or schemas

**Current Test Status:**
- ✅ 26/26 tests passing
- ✅ 96.96% code coverage
- Expected execution time: ~300-400ms

## Code Quality Standards

1. **TypeScript:**
   - Strict mode enabled
   - No `any` types (use `unknown` if needed)
   - Explicit return types for functions
   - Proper error typing

2. **Code Style:**
   - Never use placeholders like `// ... rest of code ...`
   - Always write complete implementations
   - No commented-out code in production

3. **Planning:**
   - Always provide a PLAN with REASONING before implementation
   - Base decisions on evidence from existing code
   - Consider backwards compatibility

4. **Error Handling:**
   - Use proper error classes
   - Provide meaningful error messages
   - Handle all edge cases
   - Log errors appropriately

## Database

- PostgreSQL via Prisma
- Migrations in `apps/api/prisma/migrations`
- Use Prisma MCP for database operations
- Repository pattern REQUIRED (no direct Prisma calls outside repositories)

## Environment Variables

**Backend (.env):**
```
PORT=3000
DATABASE_URL=postgresql://...
NODE_ENV=development
```

**Frontend (.env):**
```
VITE_API_URL=http://localhost:3000
```

## Git Workflow

- Meaningful commit messages
- Feature branches
- Clean commit history
- No secrets in commits

---

Remember: Quality over speed. Write clean, maintainable, tested code.
